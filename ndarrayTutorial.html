<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ndarray: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ndarray
   </div>
   <div id="projectbrief">NumPy-friendly multidimensional arrays in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="installation"></a>
Installation</h1>
<p >ndarray is a header-only library; after downloading and unpacking the source, you can start using it immediately simply by adding it to your compiler's include path.</p>
<p >For tests, we use the Cmake build system, but CMake is not necessary to make use of the library.</p>
<h1><a class="anchor" id="construction"></a>
Creating New Arrays</h1>
<p ><a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> objects have two normal constructors intended for public use, the default constructor and a converting copy constructor. The default constructor creates an "empty" array, with a null data pointer and zero shape. The copy constructor creates a shared view into an existing array.</p>
<h2><a class="anchor" id="new_arrays"></a>
New Memory</h2>
<p >To create a new non-trivial array, one can use the allocate function, which returns a temporary object implicitly convertible to <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,3,3&gt;</a> a = <a class="code hl_function" href="group__MainGroup.html#ga2860aef47c8df3e751f19c73efc68631">allocate</a>(makeVector(3,4,5));</div>
<div class="line"><span class="comment">// equivalent to</span></div>
<div class="line"><span class="comment">// &gt;&gt;&gt; a = numpy.empty((3,4,5),dtype=float)</span></div>
<div class="line"><span class="comment">// in Python</span></div>
<div class="ttc" id="aclassndarray_1_1Array_html"><div class="ttname"><a href="classndarray_1_1Array.html">ndarray::Array</a></div><div class="ttdoc">A multidimensional strided array.</div><div class="ttdef"><b>Definition:</b> Array.h:35</div></div>
<div class="ttc" id="agroup__MainGroup_html_ga2860aef47c8df3e751f19c73efc68631"><div class="ttname"><a href="group__MainGroup.html#ga2860aef47c8df3e751f19c73efc68631">ndarray::allocate</a></div><div class="ttdeci">detail::SimpleInitializer&lt; N &gt; allocate(Vector&lt; U, N &gt; const &amp;shape)</div><div class="ttdoc">Create an expression that allocates uninitialized memory for an array.</div><div class="ttdef"><b>Definition:</b> initialization.h:104</div></div>
</div><!-- fragment --><p> The makeVector function here is a variable-argument-length constructor for the <a class="el" href="structndarray_1_1Vector.html" title="A fixed-size 1D array class.">Vector</a> object, a fixed-size array class whose int variant is used to specify shape and strides for <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>. The appropriate <a class="el" href="structndarray_1_1Vector.html" title="A fixed-size 1D array class.">Vector</a> template for a particular <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> template is available as the Index typedef within the <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> class.</p>
<p >The allocate function can also take an STL allocator as a template argument and/or regular argument: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,3,3&gt;</a> a = allocate&lt; std::allocator&lt;void&gt; &gt;(makeVector(3,4,5));</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,3,3&gt;</a> a = <a class="code hl_function" href="group__MainGroup.html#ga2860aef47c8df3e751f19c73efc68631">allocate</a>(makeVector(3,4,5), std::allocator&lt;void&gt;());</div>
</div><!-- fragment --><p> Note that the type of the allocator does not have to match the type of the array; the allocator's "rebind" member will be used to create the correct allocator when the array is constructed. Furthermore, unlike standard library containers, <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> is not templated on its allocator type; after construction, it is impossible to determine how an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>'s memory was allocated. An <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> constructed by allocate is not generally initialized to any value (do not assume it contains zeros). </p>
<h2><a class="anchor" id="external_memory"></a>
External Memory</h2>
<p >Arrays can also be constructed that point to external data: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,1,1&gt;::Owner</a> owner(std::malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*5), std::free);</div>
<div class="line"><a class="code hl_class" href="structndarray_1_1Vector.html">Array&lt;double,1,1&gt;::Index</a> shape = makeVector(5);</div>
<div class="line"><a class="code hl_class" href="structndarray_1_1Vector.html">Array&lt;double,1,1&gt;::Index</a> strides = makeVector(1);</div>
<div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,1,1&gt;</a> a = <a class="code hl_function" href="group__MainGroup.html#ga6ef45bfae80081f04cee80768c6f05e0">external</a>(owner.get(), shape, strides, owner);</div>
<div class="ttc" id="agroup__MainGroup_html_ga6ef45bfae80081f04cee80768c6f05e0"><div class="ttname"><a href="group__MainGroup.html#ga6ef45bfae80081f04cee80768c6f05e0">ndarray::external</a></div><div class="ttdeci">detail::ExternalInitializer&lt; T, N, Owner &gt; external(T *data, Vector&lt; U, N &gt; const &amp;shape, Vector&lt; V, N &gt; const &amp;strides, Owner const &amp;owner)</div><div class="ttdoc">Create an expression that initializes an Array with externally allocated memory.</div><div class="ttdef"><b>Definition:</b> initialization.h:176</div></div>
<div class="ttc" id="astructndarray_1_1Vector_html"><div class="ttname"><a href="structndarray_1_1Vector.html">ndarray::Vector</a></div><div class="ttdoc">A fixed-size 1D array class.</div><div class="ttdef"><b>Definition:</b> Vector.h:82</div></div>
</div><!-- fragment --><p> The 'strides' vector here specifies the space between elements in each dimension; the dot product of the strides vector with an index vector should give the offset of the element with that index from the first element of the array. The 'Owner' type here is a typedef to a boost::shared_ptr, which can take an arbitrary functor as a custom deleter (here, std::free). By defining an appropriate deleter, an array can manage virtually any kind of memory. However, it is also possible to create an array with no reference counting by passing an empty owner (or passing none at all): </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="keywordtype">double</span> data[] = { 5.3, 1.2, 6.3, 2.8, 7.0 };</div>
<div class="line"><a class="code hl_typedef" href="classndarray_1_1ArrayBase.html#af0de7689d1f3eafdd8c1afac9b889b97">Array&lt;double,1,1&gt;::Index</a> shape = makeVector(5);</div>
<div class="line"><a class="code hl_typedef" href="classndarray_1_1ArrayBase.html#af0de7689d1f3eafdd8c1afac9b889b97">Array&lt;double,1,1&gt;::Index</a> strides = makeVector(1);</div>
<div class="line">Array&lt;double,1,1&gt; a = <a class="code hl_function" href="group__MainGroup.html#ga6ef45bfae80081f04cee80768c6f05e0">external</a>(data, shape, strides);</div>
<div class="ttc" id="aclassndarray_1_1ArrayBase_html_af0de7689d1f3eafdd8c1afac9b889b97"><div class="ttname"><a href="classndarray_1_1ArrayBase.html#af0de7689d1f3eafdd8c1afac9b889b97">ndarray::ArrayBase::Index</a></div><div class="ttdeci">Vector&lt; Size, ND::value &gt; Index</div><div class="ttdoc">Vector type for N-dimensional indices and shapes.</div><div class="ttdef"><b>Definition:</b> ArrayBase.h:62</div></div>
</div><!-- fragment --><p> In this case, the user is responsible for ensuring that the data pointer provided to the array remains valid during the array's lifetime, and is eventually deallocated later.</p>
<h1><a class="anchor" id="assignment"></a>
Assignment</h1>
<p >Direct <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> assignment is shallow: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,1,1&gt;</a> a = <a class="code hl_function" href="group__MainGroup.html#ga2860aef47c8df3e751f19c73efc68631">allocate</a>(makeVector(5));</div>
<div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,1,1&gt;</a> b;</div>
<div class="line">b = a; <span class="comment">// the two arrays now share data.</span></div>
</div><!-- fragment --><p> To actually set the elements of an array, we can use <a class="el" href="classndarray_1_1ArrayBase.html#a93db2369043c8ef67296fd712b3f7527" title="Return an ArrayRef view to this.">Array::deep()</a>: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,11,&gt;</a> b = <a class="code hl_function" href="group__MainGroup.html#ga2860aef47c8df3e751f19c73efc68631">allocate</a>(a.<a class="code hl_function" href="classndarray_1_1ArrayBase.html#aeb5d0baa531879c961f1418714e4a517">getShape</a>());</div>
<div class="line">b.<a class="code hl_function" href="classndarray_1_1ArrayBase.html#a93db2369043c8ef67296fd712b3f7527">deep</a>() = a; <span class="comment">// &#39;b&#39; is now a deep copy of &#39;a&#39;.</span></div>
<div class="ttc" id="aclassndarray_1_1ArrayBase_html_a93db2369043c8ef67296fd712b3f7527"><div class="ttname"><a href="classndarray_1_1ArrayBase.html#a93db2369043c8ef67296fd712b3f7527">ndarray::ArrayBase::deep</a></div><div class="ttdeci">Deep const deep() const</div><div class="ttdoc">Return an ArrayRef view to this.</div><div class="ttdef"><b>Definition:</b> ArrayBase.h:191</div></div>
<div class="ttc" id="aclassndarray_1_1ArrayBase_html_aeb5d0baa531879c961f1418714e4a517"><div class="ttname"><a href="classndarray_1_1ArrayBase.html#aeb5d0baa531879c961f1418714e4a517">ndarray::ArrayBase::getShape</a></div><div class="ttdeci">Index getShape() const</div><div class="ttdoc">Return a Vector of the sizes of all dimensions.</div><div class="ttdef"><b>Definition:</b> ArrayBase.h:149</div></div>
</div><!-- fragment --><p> Scalar assignment and augmented assignment operations are also supported: </p><div class="fragment"><div class="line">b.<a class="code hl_function" href="classndarray_1_1ArrayBase.html#a93db2369043c8ef67296fd712b3f7527">deep</a>() = 5.2;</div>
<div class="line">b.<a class="code hl_function" href="classndarray_1_1ArrayBase.html#a93db2369043c8ef67296fd712b3f7527">deep</a>() += a;</div>
</div><!-- fragment --><p> The deep() method returns a proxy <a class="el" href="classndarray_1_1ArrayRef.html" title="A proxy class for Array with deep assignment operators.">ArrayRef</a> object, which behaves just like an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> aside from its assignment operators, and is implicitly convertible to <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>.</p>
<h1><a class="anchor" id="indexing_and_iteration"></a>
Indexing and Iteration</h1>
<p >A multidimensional <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> behaves like a container of Arrays with lower dimensions, while a one-dimensional <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> behaves like a container of elements: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> data = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };</div>
<div class="line">Array&lt;int,2,2&gt; a = <a class="code hl_function" href="group__MainGroup.html#ga6ef45bfae80081f04cee80768c6f05e0">external</a>(data, makeVector(4,3));</div>
<div class="line"><span class="comment">// make &#39;b&#39; a view into the second row of &#39;a&#39; (Reference is a typedef to Array&lt;int,1,1&gt;):</span></div>
<div class="line"><a class="code hl_typedef" href="classndarray_1_1ArrayBase.html#aa2c184ab5475e6dfe1fbcd37f795bb4f">Array&lt;int,2,2&gt;::Reference</a> br = a[1]; <span class="comment">// br is an ArrayRef&lt;int,1,1&gt;.</span></div>
<div class="line"><a class="code hl_typedef" href="classndarray_1_1ArrayBase.html#a8ce78d5712a644faee9dc77ebdd6a896">Array&lt;int,2,2&gt;::Value</a> b = a[1];      <span class="comment">// b is an Array&lt;int,1,1&gt;</span></div>
<div class="line">Array&lt;int,2,2&gt;::Element b0 = b[0];   <span class="comment">// b0 == 6; Element is a typedef to int.</span></div>
<div class="line">Array&lt;int,2,2&gt;::Reference::Value b1 = b[1];     <span class="comment">// b1 == 7; Reference::Value is also int.</span></div>
<div class="line">Array&lt;int,2,2&gt;::Reference::Reference b2 = b[2]; <span class="comment">// b2 == 8; Reference::Reference is int&amp;.</span></div>
<div class="ttc" id="aclassndarray_1_1ArrayBase_html_a8ce78d5712a644faee9dc77ebdd6a896"><div class="ttname"><a href="classndarray_1_1ArrayBase.html#a8ce78d5712a644faee9dc77ebdd6a896">ndarray::ArrayBase::Value</a></div><div class="ttdeci">Traits::Value Value</div><div class="ttdoc">Nested array or element value type.</div><div class="ttdef"><b>Definition:</b> ArrayBase.h:56</div></div>
<div class="ttc" id="aclassndarray_1_1ArrayBase_html_aa2c184ab5475e6dfe1fbcd37f795bb4f"><div class="ttname"><a href="classndarray_1_1ArrayBase.html#aa2c184ab5475e6dfe1fbcd37f795bb4f">ndarray::ArrayBase::Reference</a></div><div class="ttdeci">Traits::Reference Reference</div><div class="ttdoc">Nested array or element reference.</div><div class="ttdef"><b>Definition:</b> ArrayBase.h:54</div></div>
</div><!-- fragment --><p> Indexing operations return <a class="el" href="classndarray_1_1ArrayRef.html" title="A proxy class for Array with deep assignment operators.">ArrayRef</a> objects, not Arrays. This allows them to be assigned to without manually calling deep(): </p><div class="fragment"><div class="line">a[1] -= 3; <span class="comment">// subtract three from the entire second row.</span></div>
</div><!-- fragment --><p >For one dimensional arrays, the "Reference" typedef is equivalent to "Element &amp;", while the "Value" typedef is equivalent to "Element". For multidimensional arrays, "Reference" is a lower-dimensional <a class="el" href="classndarray_1_1ArrayRef.html" title="A proxy class for Array with deep assignment operators.">ArrayRef</a>, while "Value" is a lower-dimensional <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>.</p>
<p ><a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> is designed to have lightweight nested iterators, with types provided by the <a class="el" href="classndarray_1_1ArrayBase.html#a8bad27bccdad58f118327b25b6775288" title="Nested array or element iterator.">Array::Iterator</a> typedef. For contiguous one-dimensional arrays (Array&lt;T,1,1&gt;), this is a typedef to a simple pointer. The typical pattern to iterate over a 3-dimensional array looks like the following: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,3,3&gt;</a> a = <a class="code hl_function" href="group__MainGroup.html#ga2860aef47c8df3e751f19c73efc68631">allocate</a>(makeVector(5,6,8));</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code hl_typedef" href="classndarray_1_1ArrayBase.html#a8bad27bccdad58f118327b25b6775288">Array&lt;double,3,3&gt;::Iterator</a> i = a.<a class="code hl_function" href="classndarray_1_1ArrayBase.html#adcf22fd72dbdd04d68299e2c53c61b13">begin</a>(); i != a.<a class="code hl_function" href="classndarray_1_1ArrayBase.html#a97e3a349851cd77be1fd395edc0598ed">end</a>(); ++i) {</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,3,3&gt;::Reference::Iterator</a> j = i-&gt;<a class="code hl_function" href="classndarray_1_1ArrayBase.html#adcf22fd72dbdd04d68299e2c53c61b13">begin</a>(); j != i-&gt;end(); ++j) {</div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,3,3&gt;::Reference::Reference::Iterator</a> k = j-&gt;<a class="code hl_function" href="classndarray_1_1ArrayBase.html#adcf22fd72dbdd04d68299e2c53c61b13">begin</a>(); k != j-&gt;end(); ++k) {</div>
<div class="line">             <span class="comment">// *k == a[i - a.begin()][j - i-&gt;begin()][k - j-&gt;begin()];</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassndarray_1_1ArrayBase_html_a8bad27bccdad58f118327b25b6775288"><div class="ttname"><a href="classndarray_1_1ArrayBase.html#a8bad27bccdad58f118327b25b6775288">ndarray::ArrayBase::Iterator</a></div><div class="ttdeci">Traits::Iterator Iterator</div><div class="ttdoc">Nested array or element iterator.</div><div class="ttdef"><b>Definition:</b> ArrayBase.h:52</div></div>
<div class="ttc" id="aclassndarray_1_1ArrayBase_html_a97e3a349851cd77be1fd395edc0598ed"><div class="ttname"><a href="classndarray_1_1ArrayBase.html#a97e3a349851cd77be1fd395edc0598ed">ndarray::ArrayBase::end</a></div><div class="ttdeci">Iterator end() const</div><div class="ttdoc">Return an Iterator to one past the end of the array.</div><div class="ttdef"><b>Definition:</b> ArrayBase.h:109</div></div>
<div class="ttc" id="aclassndarray_1_1ArrayBase_html_adcf22fd72dbdd04d68299e2c53c61b13"><div class="ttname"><a href="classndarray_1_1ArrayBase.html#adcf22fd72dbdd04d68299e2c53c61b13">ndarray::ArrayBase::begin</a></div><div class="ttdeci">Iterator begin() const</div><div class="ttdoc">Return an Iterator to the beginning of the array.</div><div class="ttdef"><b>Definition:</b> ArrayBase.h:96</div></div>
</div><!-- fragment --><p> As expected, the iterators of multidimensional arrays dereference to lower-dimensional arrays, and the iterators of one-dimensional arrays dereference to elements. With some compilers, it may be advantageous to move the calls to end() outside their loops.</p>
<p >Just like direct indexing, multidimensional array iterators dereference to <a class="el" href="classndarray_1_1ArrayRef.html" title="A proxy class for Array with deep assignment operators.">ArrayRef</a>, not <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>.</p>
<p >STL-compliant typedefs "iterator", "const_iterator", "reference", "const_reference", and "value" are also provided, though the const variants are not actually const (because <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> provides smart-pointer const-correctness rather than container const-correctness).</p>
<p >Single elements can be extracted from multidimensional arrays by indexing with <a class="el" href="structndarray_1_1Vector.html" title="A fixed-size 1D array class.">ndarray::Vector</a>: </p><div class="fragment"><div class="line">a[makeVector(3,2,1)] == a[3][2][1];</div>
</div><!-- fragment --><h1><a class="anchor" id="ndarrayTutorialViews"></a>
Views</h1>
<p >General views into an <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> are created by passing a ViewDef object to the [] operators of <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a>, returning a new <a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> that shares data and owns a reference to the original.</p>
<p >ViewDef involves a lot of template metaprogramming, so the actual template class is an internal detail, and ViewDefs are constructed by calls to the <a class="el" href="group__ndarrayMainGroup.html#ga63e7f29d98c66fad64208e0912669e9f" title="Start a view definition that includes the entire first dimension.">view()</a> function function followed by chained calls to the function call operator, resulting in a syntax that looks like this: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,5&gt;</a> a = <a class="code hl_function" href="group__MainGroup.html#ga2860aef47c8df3e751f19c73efc68631">allocate</a>(makeVector(3,5,2,6,4));</div>
<div class="line">b = a[<a class="code hl_function" href="group__ndarrayMainGroup.html#ga63e7f29d98c66fad64208e0912669e9f">view</a>(1)(0,3)()(4)];</div>
<div class="ttc" id="agroup__ndarrayMainGroup_html_ga63e7f29d98c66fad64208e0912669e9f"><div class="ttname"><a href="group__ndarrayMainGroup.html#ga63e7f29d98c66fad64208e0912669e9f">ndarray::view</a></div><div class="ttdeci">View&lt; boost::fusion::vector1&lt; index::Full &gt; &gt; view()</div><div class="ttdoc">Start a view definition that includes the entire first dimension.</div><div class="ttdef"><b>Definition:</b> views.h:121</div></div>
</div><!-- fragment --><p> which is equivalent to the Python code: </p><div class="fragment"><div class="line">a = numpy.<a class="code hl_function" href="classndarray_1_1ExpressionBase.html#ad8e257788d43b6e7813003ebc1f2ae52">empty</a>((3,5,2,6,4),dtype=<span class="keywordtype">float</span>)</div>
<div class="line">b = a[1,0:3,:,4]</div>
<div class="ttc" id="aclassndarray_1_1ExpressionBase_html_ad8e257788d43b6e7813003ebc1f2ae52"><div class="ttname"><a href="classndarray_1_1ExpressionBase.html#ad8e257788d43b6e7813003ebc1f2ae52">ndarray::ExpressionBase::empty</a></div><div class="ttdeci">bool empty() const</div><div class="ttdoc">Return true if the first dimension has no elements.</div><div class="ttdef"><b>Definition:</b> ExpressionBase.h:96</div></div>
</div><!-- fragment --><p> The value passed to each call specifies how to extract values from that dimension:</p>
<ul>
<li>A single integer selects a single subarray from that dimension, reducing the overall dimensionality of the view relative to the parent array by one.</li>
<li>An empty call selects the entire dimension.</li>
<li>A pair of integers selects a contiguous subset of subarrays from that dimension.</li>
<li>A triplet of integers selects a noncontiguous subset of subarrays from that dimension.</li>
</ul>
<p >Any dimensions which are not specified because the length of the ViewDef expression is smaller than the dimensionality of the parent array will be considered full-dimension selections: </p><div class="fragment"><div class="line">a[<a class="code hl_function" href="group__ndarrayMainGroup.html#ga63e7f29d98c66fad64208e0912669e9f">view</a>(3)] == a[<a class="code hl_function" href="group__ndarrayMainGroup.html#ga63e7f29d98c66fad64208e0912669e9f">view</a>(3)()()()()];</div>
</div><!-- fragment --><h1><a class="anchor" id="operators"></a>
Arithmetic Operators and Comparison</h1>
<p >Arrays provide element-wise arithmetic operations that make use of expression templates: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,2,2&gt;</a> a = <a class="code hl_function" href="group__MainGroup.html#ga2860aef47c8df3e751f19c73efc68631">allocate</a>(makeVector(3,4));</div>
<div class="line"><span class="comment">// initialize the elements of &#39;a&#39;</span></div>
<div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,2,2&gt;</a> b = <a class="code hl_function" href="group__MainGroup.html#ga2860aef47c8df3e751f19c73efc68631">allocate</a>(a.<a class="code hl_function" href="classndarray_1_1ArrayBase.html#aeb5d0baa531879c961f1418714e4a517">getShape</a>());</div>
<div class="line">b = a * 3 + 2; <span class="comment">// this expression is lazy, and never allocates a temporary array</span></div>
</div><!-- fragment --><p> We can simplify the previous example by initializing 'b' with the <a class="el" href="group__MainGroup.html#ga148e564952a0cf8b9eb7562107f22d5c" title="Create a new Array by copying an Expression.">copy()</a> function, which is simply a shortcut for allocate and assign: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,2,2&gt;</a> a = <a class="code hl_function" href="group__MainGroup.html#ga2860aef47c8df3e751f19c73efc68631">allocate</a>(makeVector(3,4));</div>
<div class="line"><span class="comment">// initialize the elements of &#39;a&#39;</span></div>
<div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,2,2&gt;</a> b = <a class="code hl_function" href="group__MainGroup.html#ga148e564952a0cf8b9eb7562107f22d5c">copy</a>(a * 3 + 2);</div>
<div class="ttc" id="agroup__MainGroup_html_ga148e564952a0cf8b9eb7562107f22d5c"><div class="ttname"><a href="group__MainGroup.html#ga148e564952a0cf8b9eb7562107f22d5c">ndarray::copy</a></div><div class="ttdeci">ArrayRef&lt; typename boost::remove_const&lt; typename Derived::Element &gt;::type, Derived::ND::value, Derived::ND::value &gt; copy(ExpressionBase&lt; Derived &gt; const &amp;expr)</div><div class="ttdoc">Create a new Array by copying an Expression.</div><div class="ttdef"><b>Definition:</b> initialization.h:141</div></div>
</div><!-- fragment --><p> As a rule, ndarray never allocates memory for a new array unless you explicitly tell it to with the <a class="el" href="group__MainGroup.html#ga2860aef47c8df3e751f19c73efc68631" title="Create an expression that allocates uninitialized memory for an array.">allocate()</a> or <a class="el" href="group__MainGroup.html#ga148e564952a0cf8b9eb7562107f22d5c" title="Create a new Array by copying an Expression.">copy()</a> functions.</p>
<p >Element-wise comparisons are also supported, but not via overloaded operators: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,2,2&gt;</a> a = <a class="code hl_function" href="group__MainGroup.html#ga2860aef47c8df3e751f19c73efc68631">allocate</a>(makeVector(3,4));</div>
<div class="line"><span class="comment">// initialize the elements of &#39;a&#39;</span></div>
<div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,2,2&gt;</a> b = <a class="code hl_function" href="group__MainGroup.html#ga2860aef47c8df3e751f19c73efc68631">allocate</a>(makeVector(3,4));</div>
<div class="line"><span class="comment">// initialize the elements of &#39;b&#39;</span></div>
<div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;bool,2,2&gt;</a> c = <a class="code hl_function" href="group__MainGroup.html#ga148e564952a0cf8b9eb7562107f22d5c">copy</a>(equal(a, b));</div>
</div><!-- fragment --><p> The element-wise comparison functions (equal, not_equal, less, less_equal, greater, greater_equal) and logical operators (logical_and, logical_or, logical_not) are also lazy, and are most useful when used in conjunction with the reduction functions all() and any(): </p><div class="fragment"><div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,2,2&gt;</a> a = <a class="code hl_function" href="group__MainGroup.html#ga2860aef47c8df3e751f19c73efc68631">allocate</a>(makeVector(3,4));</div>
<div class="line"><span class="comment">// initialize the elements of &#39;a&#39;</span></div>
<div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,2,2&gt;</a> b = <a class="code hl_function" href="group__MainGroup.html#ga2860aef47c8df3e751f19c73efc68631">allocate</a>(makeVector(3,4));</div>
<div class="line"><span class="comment">// initialize the elements of &#39;b&#39;</span></div>
<div class="line"><span class="keywordtype">bool</span> v1 = all(logical_or(greater(a, b), greater(a, 3.0)));</div>
<div class="line"><span class="keywordtype">bool</span> v2 = any(less(b, a));</div>
</div><!-- fragment --><p ><a class="el" href="classndarray_1_1Array.html" title="A multidimensional strided array.">Array</a> does overload the equality and inequality operators, but these compare for "shallow" equality, not element-wise equality: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,2,2&gt;</a> a = <a class="code hl_function" href="group__MainGroup.html#ga2860aef47c8df3e751f19c73efc68631">allocate</a>(makeVector(3,4));</div>
<div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double,2,2&gt;</a> b = <a class="code hl_function" href="group__MainGroup.html#ga148e564952a0cf8b9eb7562107f22d5c">copy</a>(a);</div>
<div class="line"><span class="keywordtype">bool</span> v1 = (a == b); <span class="comment">// false, because &#39;a&#39; and &#39;b&#39; do not share data.</span></div>
<div class="line"><a class="code hl_class" href="classndarray_1_1Array.html">Array&lt;double const,2,1&gt;</a> c(a);</div>
<div class="line"><span class="keywordtype">bool</span> v2 = (a == c); <span class="comment">// true, because &#39;a&#39; and &#39;c&#39; have the same data, shape, and strides.</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 5 2022 20:27:55 for ndarray by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
